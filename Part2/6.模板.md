## 简介

本节是对之前提到的模板（**类模板、函数模板**）的使用做更详细的介绍和解释。

在模板这一节中，除了上述两套模板，还添加了**成员模板**。

这一节可能跨越的课程会比较多（可能是视频分太多p了？），所以文档会相对较长。

**注意：编译器在编译模板时，是不知道模板真正的类型是什么，是不能保证后面使用的正确性。<u>*当模板被真正使用后，编译器会对使用部分再编译一次*</u>。**

## 类模板

![1679447518284](image/1679447518284.png)

在之前的课程中，如上图，在 [part1.2.头文件与类声明简介](../Part1/2.头文件与类声明简介) 和 [part1.10.一些补充](../Part1/10.一些补充) 中简单介绍了模板类，意为在类中的成员可以为各种类型，便可以声明一个模板类（<u>*上半部分黄色*</u>），在使用时再确定使用的类（<u>*下半部分黄色*</u>）。

## 函数模板

![1679447767223](image/1679447767223.png)

在 [part1.10.一些补充](../Part1/10.一些补充) 中，介绍了函数模板，与类模板的概念一样，都是为了各种不同的类能使用。

与模板类不同的是，在使用时，类模板需要指定类型，而函数模板在使用时，不必指明类型，在调用模板函数时，编译器会执行以下操作，以上图为例：

> 1.调用min，先确定参数类型，确认参数的类为 stone
>
> 2.函数体中，min 的操作为 < 比较，编译器会去寻找该类的 < 比较定义，在这个例子中为 stone 类的 operator< 操作符。

## 成员模板

### pair

![1679448246697](image/1679448246697.png)

如上图，使用 pair 做例子。成员模板为<u>*上图黄色部分*</u>：**这一块是模板类中的一个成员，并且这个<u>成员自身是一个模板</u>**。即在 T1 T2被确定后，U1 U2还能继续被确定。

![1679448659784](image/1679448659784.png)

以上图的pair为例，先维护一套继承关系（<u>*左上角*</u>），这里将这些继承关系分为 鱼类->鲫鱼 以及 鸟类->麻雀（<u>*右上角*</u>）。

在成员模板被使用时（<u>*左下角*</u>），可以将一个由 **pair<Derived1, Derived2>()**（鲫鱼，麻雀的pair）**作为参数**，**放入到**一个 **pair<Base1, Base2>()**（鱼类，鸟类的pair）中。

在<u>*右下角*</u> pair 的成员模板中，**其实是将传入的 pair 的 first, second（头尾）作为自身的头尾**，那么在上述例子中，**由于 <u>*Derived1 继承自 Base1，Derived2 继承自 Base2，所以是可以进行转换*</u>的**。那么也回答了<u>*左下角*</u>的问题：<u>这样传参是可以的，反之则不行。</u>

### 智能指针

![1679449441308](image/1679449441308.png)

再看一个例子，在智能指针中，也有成员模板。同理，如<u>*下半部分*</u>的使用，智能指针**为了模拟 up-cast** （向上转型），使用了和pair一样的成员模板操作。

## 模板特化

模板是一种泛化，只是简单声明一个类型，在使用时在确定；那么**模板特化（specialization）与泛化相反，<u>*在使用特殊的类型时，有一些特殊的设计*</u>**，这就成为特化。

![1679449822908](image/1679449822908.png)

如上图，在 hash 为泛化（<u>*上半部分*</u>）。

那么，在 hash 被特化后，他的写法就为

```C++
template<>
struct hash<char>{};
```

可以理解为：class Key 被绑定，所以 template 后的参数为空。所以，**当使用者将 hash 的类型定义为 char / int / long 时，编译器则会去执行已被特化部分的代码**（<u>*下半部分*</u>）。

如当使用者

```c++
cout << hash<long>(1000);
```

时，<u>***编译器先去寻找 hash 的泛化版本，然后发现有类型为 long 的特化版本后，则去使用这个被特化后的版本。***</u>

## 模板偏特化

偏特化，指的是在泛型中，参数个数的偏，或者说范围上的偏（后者比较难理解）。

### 个数的偏

![1679450979218](image/1679450979218.png)

如上图，类 vector 是一个泛化模板类，有两个参数。

那么在语法上，通过指定第一个参数（<u>*下半部分，T ----> bool*</u>），那么就是实现了一种偏特化。

**注意：个数的偏特化，只能从左到右，不能跳着偏。例如 5 个参数，只特化 1 3 5，这样是不行的。**

### 范围的偏

![1679451197451](image/1679451197451.png)

如上图，如果设计为类型 T，<u>若需要特化 T 的指针版本 T*</u>，那么c++也会支持这种想法。

那么通过将其特化为指针版本后，使用者在将类型定义为一个指针时，编译器则会去使用指针偏特化的版本。

## 模板模板参数

看上去很绕😓，其实这里的意思是指：**将一个模板作为模板参数。**

![1679451613463](image/1679451613463.png)

如上图<u>*黄色部分*</u>，这是一个模板参数，但是它同时也是一个模板。<u>***注意：只有在template<>尖括号里面的各个参数，才能将typename和class共通，可以随意使用。***</u>

那么，在使用上，如同<u>*灰色部分*</u>，传入一个元素类型，并且传入一个容器。

**注意：在使用部分，第一行打了一个❌，因为<u>*容器 list 中有第二个模板参数，平时使用时没有写，因为他有默认值*</u>；但是在作为模板模板参数传入时，必须像 <u>*中间部分*</u> 那样，这是 c++2.0 新增语法（暂时不介绍），才能正常使用。**

> <u>*侯捷老师解释这里不需要注意这个❌，只需要注意黄色部分以及标题之间的关系即可。*</u>

### 使用模板模板参数来打印容器元素

```C++
template<typename ElementType, typename allocatorType = allocator<ElementType>, //声明容器所需要的 元素类型 和 分配器类型
    template <typename ElementType, typename allocatorType>
        typename ContainerType  //声明 ContainerType 是由两个参数构成的模板
>
void PrintContainer(const ContainerType<ElementType, allocatorType>& container) {
    for (auto iter = container.begin(); iter != container.end(); iter++)
        cout << *iter << ", ";
    cout << endl;
}
```

如上述代码块，是一个模板函数，该函数的参数有三个：

> 1.**ElementType**：表示容器中**元素的类型**
>
> 2.**allocatorType**：表示容器中**分配器的类型**，<u>*这里使用了容器中的默认分配器 allocator*</u>
>
> 3.**ContainerType**：表示输入的**容器类型**，<u>***是一个模板，并且作为函数的模板参数之一***</u>。
>
> ​	**注意：** **在模板模板参数的声明中，和普通的声明一个函数（类）是一样的，<u>*都是使用 template 关键字，然后列举出改模板需要哪些模板参数*</u>。**

### 这不是模板模板参数

![1679452344773](image/1679452344773.png)

如上图stack的实现，第二个模板参数为 class Sequence = dequeue<T>，但是这个参数其实不是模板模板参数，原因是在使用时（<u>*灰色部分*</u>），**传入的参数已经不再是一个模板**，所以这不是一个模板模板参数。

## 关于模板编写与编译

> 首先提出一个问题：<u>*为什么C++模板函数的声明与实现都放在.h文件中？*</u>

一下是查阅资料后，做的一些总结和整理，更多的引用了 [参考博客](https://blog.csdn.net/lijiayu2015/article/details/52650790).

### 正常编译操作

#### 编译

首先，一个***编译单元*（translation unit）**是<u>*指一个.cpp文件以及它所 #include 的所有.h文件*</u>。.h文件里的代码将会被扩展到包含它的.cpp文件里，**然后编译器编译该.cpp文件为一个.obj文件**（*假定我们的平台是win32*）  。

.obj文件拥有PE（Portable Executable，即windows可执行文件）文件格式，并且**本身包含的就已经是二进制码**，但是不一定能够执行，因为并不保证其中一定有main函数。

当编译器<u>*将一个工程里的所有.cpp文件以**分离的方式编译完毕**后*</u>，再**由连接器（linker）进行连接成为一个.exe文件**。  

```C++

//---------------test.h-------------------//    
void f();//这里声明一个函数f  
        
//---------------test.cpp--------------//     
#include "test.h" 
        
void f()      
{ 
	//...do something        
} //这里实现出test.h中声明的f函数  
        
//---------------main.cpp--------------//  
#include "test.h"
        
int main()        
{  
    f(); //调用f，f具有外部连接类型      
}
```

如上述示例代码：

#### 链接

test. cpp 和main.cpp 各自被编译成不同的.obj文件（姑且命名为test.obj和main.obj）。

在main.cpp中，**调用了 f 函数**，然而当编译器编译main.cpp时，它所**仅仅知道的只是main.cpp中所包含的test.h文件中的一个关于 void f(); 的声明**，所以，编译器将这里的 f 看**作外部连接类型**，即认为它的函数实现代码在另一个.obj 文件中，本例也就是 test.obj。

> **main.obj 中实际没有关于 f 函数的哪怕一行二进制代码，而这些代码实际存在于test.cpp所编译成的test.obj 中。在main.obj中对f的调用只会生成一行call指令，像这样：**
>
> **call f [C++中这个名字当然是经过 mangling[处理] 过的]**

在编译时，这个call指令显然是错误的，因为main.obj中并无一行 f 的实现代码。这就是**连接器**的任务，连接器**负责在其它的 .obj 中（本例为test.obj）<u>*寻找 f 的实现代码*</u>**，找到以后将 call f 这个指令的**调用地址换成<u>*实际的 f 的函数进入点地址*</u>**。 

> 连接器**实际上将工程里的.obj "连接" 成了一个.exe文件**。
>
> 而它最关键的任务就是上面说的，寻找一个**外部连接符号**在**另一个.obj 中的地址**，然后**替换原来的 "虚假" 地址**。 

#### 总结

**编译 main.cpp 时**，**编译器<u>*不知道 f 的实现*</u>**，所以当**碰到对它的调用时只是给出一个指示**，**指示连接器应该为它寻找f的实现体**。这也就是说 <u>*main.obj 中没有关于 f 的任何一行二进制代码*</u>。

**编译 test.cpp 时**，**编译器<u>*找到了 f 的实现*</u>**。于是乎 **f 的实现（二进制代码）出现<u>*在 test.obj 里*</u>**。

**连接时**，***<u>连接器</u>* 在 test.obj 中找到 f 的实现代码（二进制）的地址（通过符号导出表）**。然后将 main.obj中悬而未决的 call XXX 地址**改成 f 实际的地址**。完成。

### 模板编译

#### 实例化

**模板函数的代码其实并不能直接编译成二进制代码**，其中**要有一个 <u>*"实例化"*</u> 的过程**。举个例子:

```C++
//----------main.cpp------//  
template<classT>      
void f(T t)    
{
}  
       
int main()      
{      
    //...do something   
    
	f(10); // call f<int> 编译器在这里决定给f一个f<int>的实例  
    
	//...do other thing     
} 
```

如果你在 main.cpp 文件中**没有调用过 f，f 也就*得不到实例化***，从而 main.obj 中也就没有关于 f 的任意一行二进制代码！如果你这样调用了： 

> f(10); // f<int>得以实例化出来
>
> f(10.0); // f<double>得以实例化出来

**这样 main.obj 中也就有了 f<int>，f<double> 两个函数的二进制代码段**。以此类推。

>  *<u>然而实例化要求编译器**知道模板的定义**，不是吗？</u>* 

#### 分离带来的影响

```C++
//-------------test.h----------------//      
template<typename T>     
class A   
{    
public:     
	void f(); // 这里只是个声明     
};  
       
//---------------test.cpp-------------// 
#include "test.h"
template<classT>  
void A<T>::f() // 模板的实现  
{  
	//...do something    
}  
       
//---------------main.cpp---------------//  
       
#include "test.h"    
int main()  
{  
    A<int> a;  
    a.f(); // #1  
}
```

 **编译器在 #1处 并不知道 A::f 的定义，因为它不在 test.h 里面**。因此，编译器在编译 main.cpp 遇到 A<int> a 时，并**没有办法进行实例化**（没有模板定义）。

于是编译器只好寄希望于连接器，希望它能够在其他 .obj 里面找到 A::f 的实例，在本例中就是test.obj。然而，<u>***当一个模板不被用到的时侯它就不该被实例化出来***</u>。

 所以**实际上 test.cpp 编译出来的 test.obj 文件中<u>*关于 A::f 一行二进制代码也没有*</u>，于是连接器就傻眼了，只好给出一个连接错误**。

如果在 test.cpp 中写一个函数，**其中调用 A<int>::f**，则编译器会将其实例化出来，因为在这个点上（test.cpp中），**编译器知道模板的定义，所以能够实例化**，于是，<u>test.obj 的符号导出表中就有了A<int>::f 这个符号的地址，于是连接器就能够完成任务。</u> 

另外，如果在 test.cpp 中**进行模板特化**，也是可以链接成功的：

```C++
//-------------test.h----------------//      
template<typename T>
void f();
       
//---------------test.cpp-------------//
#include "test.h"
template<>
void f<int>()
{
} 
       
//---------------main.cpp---------------//  
#include "test.h"    
int main()  
{  
	f<int>();	//#1
}
```

在编译器编译 main.cpp 遇到 #1 处时，**由于找不到模板定义，所以无法实例化**，因此需要通过链接器去寻找 f<int> 的定义。

此时，test.cpp 中发现了 template<> f<int>() 的特化版本，**特化版本相当于进行了一次实例化**，所以链接器找到了 f<int>() 符号的地址，并且在生成 exe 时成功替换。